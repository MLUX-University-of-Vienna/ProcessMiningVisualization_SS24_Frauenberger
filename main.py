#co-generated by chatgpt

import sys
import csv
import os
import numpy as np
import pydot
import networkx as nx
import matplotlib.pyplot as plt
from PyQt5.QtCore import Qt, QDir, QFile
from PyQt5.QtWidgets import QApplication, QMainWindow,QStackedWidget, QMessageBox, QFileDialog,QTableWidget, QTableWidgetItem, QDockWidget,QSlider,QLabel,QWidget,QVBoxLayout
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from mining_algorithms.csv_reader import read
from mining_algorithms.heuristic_mining import HeuristicMining

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # global variables
        self.filepath = None
        self.dependency_treshhold = 0.5
        self.min_frequency = 1
        # Set up the user interface
        
        self.figure = plt.figure(figsize=(50, 50))
        welcomeText = "This is a process mining tool.\nIt can create nice looking graphs out of CSV files!\nMake sure your CSV file has the following columns: 'timestamp', 'case', 'event' "
        plt.text(0.5, 0.5, welcomeText, fontsize=24, ha='center', va='center')
        plt.axis('off')
        self.canvas = FigureCanvas(self.figure)

        # Add a table widget for display of csv
        self.table = QTableWidget(self)

        # Create a main widget that is stacked and can change depending on the needs
        self.mainWidget = QStackedWidget(self)
        self.mainWidget.addWidget(self.canvas)
        self.mainWidget.addWidget(self.table)
        self.mainWidget.setCurrentWidget(self.canvas)
        self.setCentralWidget(self.mainWidget)

        # Add a file menu to allow users to upload a CSV file
        file_menu = self.menuBar().addMenu("File")
        upload_action_csv = file_menu.addAction("Display CSV")
        upload_action_mine_csv = file_menu.addAction("Heuristic Mine CSV")
        upload_action_dot = file_menu.addAction("Display DOT File")
        export_current_image = file_menu.addAction("Export")
        upload_action_csv.triggered.connect(self.upload_csv)
        upload_action_dot.triggered.connect(self.upload_dot)
        upload_action_mine_csv.triggered.connect(self.upload_and_mine_csv)
        export_current_image.triggered.connect(self.export_current_image)

        # Set the window title and show the window
        self.setWindowTitle("Graph Viewer")
        self.show()
    
    def upload_csv(self):
        # Open a file dialog to allow users to select a CSV file
        filename, _ = QFileDialog.getOpenFileName(self, "Open CSV File", "", "CSV files (*.csv)")

        # If the user cancels the file dialog, return
        if not filename:
            return
        
        self.__reset_canvas()
        #reset the central widget to table     
        self.mainWidget.setCurrentWidget(self.table)

        # Parse the CSV file and store it in memory
        with open(filename, newline='') as csvfile:
            reader = csv.reader(csvfile, delimiter=',', quotechar='"')
            data = []
            for row in reader:
                data.append(row)

        # Display the contents of the CSV file in the app
        self.table.setRowCount(len(data))
        self.table.setColumnCount(len(data[0]))
        for i, row in enumerate(data):
            for j, val in enumerate(row):
                item = QTableWidgetItem(val)
                self.table.setItem(i, j, item)

        print("CSV uploaded")

    def upload_and_mine_csv(self):

        # Open a file dialog to allow users to select a CSV file
        filename = self.__open_csv_file()
        if not filename:
            return
        
        self.__reset_canvas()
        # change central widget
        self.mainWidget.setCurrentWidget(self.canvas)
        # read csv and draw a dependency graph
        cases = read(filename)
        self.Heuristic_Model = HeuristicMining(cases)
        self.__mine_and_draw_csv()

        self.__create_slider_dock_widget()
        self.addDockWidget(Qt.RightDockWidgetArea, self.slider_dock_widget)

    def export_current_image(self):
        # if there is no image, warn with a pop up and return.
        if not self.filepath:
            popup = QMessageBox(self)
            popup.setText("Nothing to export. Please mine a model.")

            close_button = popup.addButton("Close", QMessageBox.AcceptRole)
            close_button.clicked.connect(popup.close)

            # Show the pop-up message
            popup.exec_()

            return
        
        # Open a file dialog to allow users to select a folder
        source_folder = QDir.currentPath()+ '/temp'
        destination_folder = QFileDialog.getExistingDirectory(self, "Select a folder", QDir.currentPath())

        file_name = 'graph_viz.png'
        # Copy the file from the source folder to the destination folder
        source_file_path = os.path.join(source_folder, file_name)
        destination_file_path = os.path.join(destination_folder, file_name)
        QFile.copy(source_file_path, destination_file_path)

    def upload_dot(self):
        # Open a file dialog to allow users to select a DOT file
        filename, _ = QFileDialog.getOpenFileName(self, "Open DOT File", "", "DOT files (*.dot)")

        # If the user cancels the file dialog, return
        if not filename:
            return
        
        self.__reset_canvas()

        # change central widget
        self.mainWidget.setCurrentWidget(self.canvas)

        graph = pydot.graph_from_dot_file(filename)
        nx_graph = nx.nx_pydot.from_pydot(graph[0])
        self.figure.clear()
        nx.draw_networkx(nx_graph, with_labels=True)
        self.canvas.draw()

        print("DOT uploaded")

    def __mine_and_draw_csv(self):
        '''with networkx'''
        #nx_graph = self.Heuristic_Model.create_dependency_graph_with_networkx(self.dependency_treshhold,self.min_frequency)
        #self.figure.clear()
        #nx.draw_networkx(nx_graph, with_labels=True)
        #self.canvas.draw()

        '''with graphviz'''
        graphviz_graph = self.Heuristic_Model.create_dependency_graph_with_graphviz(self.dependency_treshhold,self.min_frequency)
        
        self.filepath = 'temp/graph_viz'
        filename = self.filepath + '.png'
        graphviz_graph.render(self.filepath,format = 'png')

        self.figure.clear()
        
        graph = plt.imread(filename)
        plt.imshow(graph)
        # Set axis limits to size of image
        plt.xlim([0, graph.shape[1]])
        plt.ylim([graph.shape[0], 0])

        # Turn off axis labels and tick marks
        plt.axis('off')

        self.canvas.draw()
        
        print("CSV mined")

    def __freq_slider_changed(self, value):
        # Update the label with the slider value
        self.freq_slider_label.setText(f"Min. Frequency: {value}")
        # Redraw graph when value changes
        self.min_frequency = value
        self.__mine_and_draw_csv()
    
    def __thresh_slider_changed(self, value):
        # Update the label with the slider value
        self.thresh_slider_label.setText(f"Dependency Threshhold: {value/100:.2f}")
        # Redraw graph when value changes
        self.dependency_treshhold = value/100
        self.__mine_and_draw_csv()

    def __open_csv_file(self):
         # Open a file dialog to allow users to select a CSV file
        filename, _ = QFileDialog.getOpenFileName(self, "Open CSV File", "", "CSV files (*.csv)")

        # If the user cancels the file dialog, return
        if not filename:
            return
        return filename
    
    def __create_slider_dock_widget(self):
        # Add the dock widget for the slider and canvas
        self.slider_dock_widget = QDockWidget("Heuristic variables")

        # Create the slider and label widgets
        self.freq_slider = QSlider(Qt.Vertical)
        self.freq_slider.setRange(0, 100)
        self.freq_slider.setValue(1)
        self.freq_slider.valueChanged.connect(self.__freq_slider_changed)

        self.freq_slider_label = QLabel("Min Frequency: 1")
        self.freq_slider_label.setAlignment(Qt.AlignCenter)

        # Create the second slider and label widgets
        self.thresh_slider = QSlider(Qt.Vertical)
        self.thresh_slider.setRange(0, 100)
        self.thresh_slider.setValue(50)
        self.thresh_slider.valueChanged.connect(self.__thresh_slider_changed)

        self.thresh_slider_label = QLabel("Dependency Threshhold: 0.50")
        self.thresh_slider_label.setAlignment(Qt.AlignCenter)

        # Create a new widget for the slider and canvas
        slider_widget = QWidget()
        slider_layout = QVBoxLayout()
        slider_layout.addWidget(self.freq_slider)
        slider_layout.addWidget(self.freq_slider_label)
        slider_layout.addWidget(self.thresh_slider)
        slider_layout.addWidget(self.thresh_slider_label)
        slider_widget.setLayout(slider_layout)

        # Adjust the size of the slider widget
        slider_widget.setMinimumWidth(100)

        # Add the slider and canvas widget to the dock widget
        self.slider_dock_widget.setWidget(slider_widget)

        # Create a new canvas for the right dock widget
        self.right_canvas = FigureCanvas(Figure(figsize=(5, 5)))
        self.slider_dock_widget.setAllowedAreas(Qt.RightDockWidgetArea)

    def __reset_canvas(self):
        if hasattr(self, 'slider_dock_widget'):
            self.removeDockWidget(self.slider_dock_widget)
        self.dependency_treshhold = 0.5
        self.min_frequency = 1

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    sys.exit(app.exec_())

